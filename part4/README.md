# 채팅서버 생성하기
* protocol : IRC
* miniIRC를 만든다고 생각하고 설계

# 채팅서버의 구조
## 1. 포트번호를 체크
- 포트번호는 보통 65535개가 있다고 함.
- 이 중 0~1023은 무조건 사용용도가 정해져 있음. (well-known port)
- 따라서 1024 ~ 65535번을 사용할 수 있게 지정.

## 2. 서버소켓 초기화
- `socket()` : 소켓을 생성하는 함수
- `setsocketopt()` : 소켓의 옵션을 조정하는 함수
	- 이전 소켓이 종료되었을 경우, 완전히 종료되었음을 확인하는 TIME_WAIT 상태가 발생
	- 이 상태에 있는 동안에는 같은 포트로 새 소켓을 이용할 수 없음.
	- 따라서 setsocketopt() 함수를 이용해 TIME_WAIT 상태를 최소화

- `bind()` : ip 주소와 port번호를 소켓에게 할당.
	- ip주소와 port번호를 설정하는 부분이 바로 serv_adr 구조체.
	- `.sin_family`: IPV4, IPV6 중 선택
	- `.sin_addr.s_addr` : ip주소 선택. INADDR_ANY 옵션을 걸면 localhost(=127.0.0.1)로 설정

- `listen()` : 연결요청 가능상태로 변경
- `fcntl()` : 논블로킹 처리

## 3. kqueue()
### 톡방(=서버)에 들어오는 사람 수가 많다면(= fd가 여러 개)? 여러 개의 요청을 받아야 한다.
- 여러개의 요청을 받는 방법 : 멀티프로세스, 멀티쓰레드. 그러나 이 두 해결책은 자원낭비가 너무 심하다. 
- 따라서, 이를 위해 하나의 프로세스(쓰레드)만으로 하는 방법 = 멀티플랙싱을 도입
- 대표적인 함수가 바로 `select()`이다.
- 특정한 방을 만들고, 여기에 모든 fd를 담아서 확인한다.

### 한 프로세스(쓰레드)면 느리지 않을까?
- 전체적인 서비스 제공시간이 늦어져도 모든 클라이언트에게 서비스를 제공하는 것이 낫다.
- cpu 연산과 관련 없는 데이터의 송수신 시간이 실제 전송시간에서는 큰 비중을 차지하므로, 이를 효율적으로 쓰기 위해서는 멀티플랙싱이 나음.

### 방에 등록된 모든 fd를 검사해야 할까?
- 이러한 의문에서 나온 것이 바로 kqueue()와 epoll()이다.
- select()로 연결을 받으면 매번 방에 담긴 모든 fd를 while()문으로 검사
- 반면, kqueue()와 epoll()은 연락이 온 fd만 검사한다.
	- 연락이라는 행동 = 이벤트로 정의.
- 유닉스에서는 kqueue(), 리눅스에서는 epoll()
	- macOS는 유닉스의 일종이므로 여기서는 kqueue()를 사용

1. 따라서, 이벤트 발생 시, 해당 이벤트에 접근하는 시간복잡도가 O(1)이다.
2. 등록된 이벤트를 따로 관리할 필요가 없다.

```c
kqueue(); // 이벤트를 담을 방(=kernel queue)을 정의
EV_SET(); // 어떤 이벤트를 받을지 정의하는 매크로 함수.
kevent(); // 이벤트를 넣고, 받은 이벤트를 넣는 함수.
```